/* TOTEM-v3.2 June 18 2008*/

/*
 * ===========================================================
 * TOTEM : A TOolbox for Traffic Engineering Methods
 * ===========================================================
 *
 * (C) Copyright 2004-2006, by Research Unit in Networking RUN, University of Liege. All Rights Reserved.
 *
 * Project Info:  http://totem.run.montefiore.ulg.ac.be
 *
 * This library is free software; you can redistribute it and/or modify it under the terms
 * of the GNU General Public License version 2.0 as published by the Free Software Foundation;
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this
 * library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
 * in the United States and other countries.]
*/
package be.ac.ulg.montefiore.run.totem.repository.CSPF;

import be.ac.ulg.montefiore.run.totem.domain.exception.*;
import be.ac.ulg.montefiore.run.totem.domain.model.*;
import be.ac.ulg.montefiore.run.totem.domain.model.jaxb.LspBackupType;
import be.ac.ulg.montefiore.run.totem.domain.model.impl.PathImpl;
import be.ac.ulg.montefiore.run.totem.domain.model.impl.LspImpl;
import be.ac.ulg.montefiore.run.totem.repository.model.*;
import be.ac.ulg.montefiore.run.totem.repository.model.exception.NoRouteToHostException;
import be.ac.ulg.montefiore.run.totem.repository.model.exception.RoutingException;
import be.ac.ulg.montefiore.run.totem.repository.model.exception.AlgorithmParameterException;
import be.ac.ulg.montefiore.run.totem.util.ParameterDescriptor;
import org.apache.log4j.Logger;

import java.util.*;


/*
 * Changes:
 * --------
 *
 * - 04-Feb-2005: make it DiffServ aware (OD).
 * - 03-May-2005: add equal cost multi path capabilities (FSK).
 * - 20-Sep-2005: add the capability to compute paths from all sources to a destination (JLE).
 * - 20-Sep-2005: code cleaning and bug fixes (JLE).
 * - 20-Sep-2005: comment corrections (JLE).
 * - 29-Nov-2005: Added the possibility to obtain the algorithm parameters (getStartAlgoParameters()). (GMO)
 * - 29-Nov-2005: Added the possibility to obtain the additional routing parameters (getPrimaryRoutingParameters()). (GMO)
 * - 08-Dec-2005: Implement new getRunningParameters() from the TotemAlgorithm interface. (GMO)
 * - 25-Feb-2006: add multiple links handling (JLE).
 * - 25-Feb-2006: comment corrections (JLE).
 * - 27-Feb-2006: better implementation for multiple links handling (JLE).
 * - 20-Mar-2006: add equals and hashCode methods (GMO).
 * - 23-Oct-2006: add default value for setup preemption level, holding preemption level and class type. Issue a warning
 *                if the preemption level is specified and the domain do not use preemptions. (GMO)
 * - 22-Nov-2006: now implements LSPBackupRouting and is able to compute detour backups (GMO)
 * - 22-Nov-2006: adapt to the new BandwidthManagement class, routeNLsp now correctly route a set of lsps (one by one) (GMO)
 * - 04-Dec-2006: make use of getReverseLink(.) method for backup computation (GMO)
 * - 15-Jan-2007: fix bug in protected links (GMO)
 * - 17-Jan-2007: bug fix: protected links are different from links to avoid (GMO)
 * - 13-Mar-2007: add reroute event to the Totem action list after preemption (GMO)
 * - 25-Sep-2007: add specific parameters for (local) detour computation (GMO)
 * - 25-Oct-2007: Fix bug with local backup ids (GMO)
 * - 05-Dec-2007: Fix bug with local backups: only one protected link possible even for node protection (GMO)
 * - 17-Dec-2007: use the snapshot interface of bandwidthMangement, also put create some instance variables instead to limit number f arguments passed (GMO)
 * - 17-Dec-2007: use detination node parameter for bypass computation, bypass LSPs ids are generated by domain method (GMO)
 * - 17-Dec-2007: Algorithm default for protection now protects nodes and last link (instead of links only) (GMO)
 * - 26-Feb-2008: make use of LspImpl setInitParameters(.) method, detour lsps can have a different bandwidth from its primary (GMO)
 */

/**
 * This class implements a Constraint Shortest Path First algorithm. This implementation supports equal cost multi path.
 * This algorithm uses a priority queue to store the temporary node list under processing.
 * <p/>
 * <p>There is no specific parameter required by this routing algorithm.
 * <p/>
 * <p>Creation date: 1-Jan-2004
 *
 * @author Fabian Skivee (skivee@run.montefiore.ulg.ac.be)
 * @author Olivier Delcourt (delcourt@run.montefiore.ulg.ac.be)
 * @author Jean Lepropre (lepropre@run.montefiore.ulg.ac.be)
 * @author GaÃ«l Monfort (monfort@run.montefiore.ulg.ac.be)
 */
public class CSPF implements SPF, LSPPrimaryRouting, LSPDetourRouting, LSPBypassRouting {

    HashMap<String, CSPFElem> path; // current computed path
    CSPFPriorityQueue tent;
    HashMap<Node, Boolean> presentInPath;
    HashMap<Node, Boolean> presentInTent;
    HashMap<Node, Float> distance;

    BandwidthManagement currentBwManagement;

    private int nbBackups; //current number of backups

    /**
     * Links to avoid in the next CSPF computation
     */
    protected Set<Link> avoidLinks;

    /**
     * Links that needs to be protected in the next backup computation
     */
    private List<Link> protectedLinks;

    private final static Logger logger = Logger.getLogger(CSPF.class);

    private final boolean PRESENT = true;
    private final boolean NOT_PRESENT = false;

    private static enum MergingPointLocation {
        NEAREST_MERGING_POINT, FARTHEST_MERGING_POINT;
    }

    private static enum MergingPointPriority {
        LOCATION_PRIORITY, END_TO_END_COST_PRIORITY;
    }

    private static final ArrayList<ParameterDescriptor> emptyParamList = new ArrayList<ParameterDescriptor>();
    private static final ArrayList<ParameterDescriptor> detourParamList = new ArrayList<ParameterDescriptor>(3);

    static {
        try {
            detourParamList.add(new ParameterDescriptor("mergePointLocation", "Specify where the local backup LSP should merge with the primary in case there are multiple shortest paths (from the ingress point of view)", String.class, "farthest", new String[] {"nearest", "farthest"}));
            detourParamList.add(new ParameterDescriptor("mergePointPriority", "Specify if the local backup LSP should be the shortest path among all paths or if merging point location is more important", String.class, "cost", new String[] {"location", "cost"}));
            detourParamList.add(new ParameterDescriptor("stopOnError", "If all local backups cannot be computed, establish none.", Boolean.class, false, new Boolean[] {true, false}));
        } catch (AlgorithmParameterException e) {
            e.printStackTrace();
        }
    }

    // start a new computation (of a (multiple) primary, detour(s), bypass)
    protected void initComputation(Domain domain) {
        avoidLinks = new HashSet<Link>(0);
        protectedLinks = new ArrayList<Link>(0);
        currentBwManagement = domain.getBandwidthManagement();
    }

    public TotemActionList routeLSP(Domain domain, LSPPrimaryRoutingParameter param) throws RoutingException, NoRouteToHostException {
        initComputation(domain);

        TotemActionList actionList = new TotemActionList();
        String srcNode = param.getSrcNode();
        String dstNode = param.getDstNode();

        //use maximum priority when diffserv not specified
        int classType = param.isSetClassType() ? param.getClassType() : domain.getMinCTValue();
        if (param.isSetSetup() && !domain.getBandwidthManagement().usePreemption())
            logger.warn("The preemption level was specified but preemptions are not used on the domain. Ignoring.");
        int preemptionLevel = param.isSetSetup() ? param.getSetup() : domain.getMaxPreemptionLevel(classType);
        int holdingPreemptionLevel = param.isSetHolding() ? param.getHolding() : domain.getMaxPreemptionLevel(classType);
        if (!domain.isExistingPriority(preemptionLevel, classType)) {
            throw new RoutingException("Error with DiffServ configuration, non existing setup priority level");
        }
        int priority = domain.getPriority(preemptionLevel, classType);
        if (!domain.isExistingPriority(holdingPreemptionLevel, classType)) {
            throw new RoutingException("Error with DiffServ configuration, non existing holding priority level");
        }

        float bw = param.getBandwidth();
        String lspId = param.getLspId();

        try {
            HashMap<String, CSPFElem> pathHM = computeCSPF(domain, priority, domain.getNode(srcNode), domain.getNode(dstNode), bw, true, true);
            Path path = extractPath(domain, pathHM, domain.getNode(srcNode), domain.getNode(dstNode), false, true).get(0);
            if (path != null) {
                StringBuffer sb = new StringBuffer("Path computed : [");
                for (int i = 0; i < path.getNodePath().size(); i++) {
                    sb.append(" " + path.getNodePath().get(i).getId());
                }
                sb.append(" ]");
                logger.debug(sb.toString());
                LspImpl lsp = new LspImpl(domain, lspId, bw, path, classType, holdingPreemptionLevel, preemptionLevel);
                lsp.setInitParameters(param);

                List<Lsp> preemptList = currentBwManagement.getPreemptList(lsp);
                if (preemptList.size() > 0) {
                    List<String> lspIds = new ArrayList<String>(preemptList.size());
                    for (Lsp it : preemptList) {
                        lspIds.add(it.getId());
                    }
                    TotemAction preemptLsp = new PreemptLspsAction(domain, lspIds);
                    actionList.add(preemptLsp);

                    TotemAction addLsp = new AddLspAction(domain, lsp);
                    actionList.add(addLsp);

                    actionList.add(new TriggerRerouteLspsAction(domain, preemptList));
                 } else {
                    TotemAction addLsp = new AddLspAction(domain, lsp);
                    actionList.add(addLsp);
                 }
            }
        } catch (NodeNotFoundException e) {
            e.printStackTrace();
        } catch (DiffServConfigurationException e) {
            throw new RoutingException("Error with DiffServ configuration, non existing priority level");
        } catch (LinkCapacityExceededException e) {
            throw new RoutingException(e);
        }
        return actionList;
    }

    public TotemActionList routeNLSP(Domain domain, List<LSPPrimaryRoutingParameter> param) throws RoutingException, NoRouteToHostException {
        initComputation(domain);
        currentBwManagement = currentBwManagement.getSnapshot();

        TotemActionList actionList = new TotemActionList();
        List<Lsp> preemptList = new ArrayList<Lsp>();

        for (int i = 0; i < param.size(); i++) {
            LSPPrimaryRoutingParameter p = param.get(i);
            String srcNode = p.getSrcNode();
            String dstNode = p.getDstNode();
            float bw = p.getBandwidth();
            String lspId = p.getLspId();

            //use maximum priority when diffserv not specified
            int classType = p.isSetClassType() ? p.getClassType() : domain.getMinCTValue();
            if (p.isSetSetup() && !domain.usePreemption())
                logger.warn("The preemption level was specified but preemptions are not used on the domain. Ignoring.");
            int preemptionLevel = p.isSetSetup() ? p.getSetup() : domain.getMaxPreemptionLevel(classType);

            if (!domain.isExistingPriority(preemptionLevel, classType)) {
                throw new RoutingException("Error with DiffServ configuration, non existing priority level");
            }
            int priority = domain.getPriority(preemptionLevel, classType);

            try {
                HashMap<String, CSPFElem> pathHM = computeCSPF(domain, priority, domain.getNode(srcNode), domain.getNode(dstNode), bw, true, true);
                Path path = extractPath(domain, pathHM, domain.getNode(srcNode), domain.getNode(dstNode), false, true).get(0);
                if (path != null) {
                    LspImpl lsp = new LspImpl(domain, lspId, bw, path, classType, preemptionLevel, preemptionLevel);
                    lsp.setInitParameters(p);

                    List<Lsp> pList = currentBwManagement.getPreemptList(lsp);
                    for (Lsp pLsp : pList) {
                        //remove Lsps from snapshot
                        currentBwManagement.removeLsp(pLsp);
                    }
                    preemptList.addAll(pList);

                    currentBwManagement.addLsp(lsp);
                    TotemAction addLsp = new AddLspAction(domain, lsp);
                    actionList.add(addLsp);
                }
            } catch (NodeNotFoundException e) {
                e.printStackTrace();
            } catch (DiffServConfigurationException e) {
                throw new RoutingException("Error with DiffServ configuration, non existing priority level");
            } catch (LinkCapacityExceededException e) {
                throw new RoutingException(e);
            } catch (LspNotFoundException e) {
                e.printStackTrace();
            }
        }
        List<String> lspIds = new ArrayList<String>(preemptList.size());
        for (Lsp it : preemptList) {
            lspIds.add(it.getId());
        }
        TotemAction preemptLsp = new PreemptLspsAction(domain, lspIds);
        actionList.add(0, preemptLsp);
        actionList.add(new TriggerRerouteLspsAction(domain, preemptList));
        return actionList;
    }

    public Path computeSPF(Domain domain, String src, String dst) throws RoutingException, NoRouteToHostException {
        return computeSPF(domain, src, dst, false).get(0);
    }

    public List<Path> computeSPF(Domain domain, String src, String dst, boolean ECMP) throws RoutingException, NoRouteToHostException {
        try {
            initComputation(domain);
            HashMap<String, CSPFElem> pathHM = computeCSPF(domain, domain.getMinPriority(), domain.getNode(src), domain.getNode(dst), 0, true, true);
            List<Path> path = extractPath(domain, pathHM, domain.getNode(src), domain.getNode(dst), ECMP, true);
            /*for (int i = 0; i < path.size(); i++) {
                Path path1 = path.get(i);
                List<Node> nodeList = path1.getNodePath();
                if (nodeList != null) {
                    StringBuffer sb = new StringBuffer("Path computed : [");
                    for (int j = 0; j < nodeList.size(); j++) {
                        sb.append(" " + nodeList.get(j).getId());
                    }
                    sb.append(" ]");
                    logger.debug(sb.toString());
                }
            } */
            return path;
        } catch (NodeNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<Path> computeSPF(Domain domain, String src) throws RoutingException, NoRouteToHostException {
        return computeSPF(domain, true, src);
    }

    public List<Path> computeSPF(Domain domain, boolean isSource, String node) throws RoutingException, NoRouteToHostException {
        return computeSPF(domain, isSource, node, false);
    }

    public List<Path> computeSPF(Domain domain, String src, boolean ECMP) throws RoutingException, NoRouteToHostException {
        return computeSPF(domain, true, src, ECMP);
    }

    public List<Path> computeSPF(Domain domain, boolean isSource, String node, boolean ECMP) throws RoutingException, NoRouteToHostException {
        initComputation(domain);

        HashMap<String, CSPFElem> path = null;
        List<Path> allPath = null;
        try {
            if (isSource) {
                path = computeCSPF(domain, domain.getMinPriority(), domain.getNode(node), null, 0, false, true);
            } else {
                path = computeCSPF(domain, domain.getMinPriority(), null, domain.getNode(node), 0, false, false);
            }

            allPath = extractPath(domain, path, domain.getNode(node), ECMP, isSource);
        } catch (NodeNotFoundException e) {
            throw new RoutingException(e);
        }

        if (allPath != null) {
            for (Path currentPath : allPath) {
                if (isSource && (currentPath.getSourceNode() == null)) {
                    throw new RoutingException("Error in the compute SPF source node is not in the PATH");
                } else if (!isSource && (currentPath.getDestinationNode() == null)) {
                    throw new RoutingException("Error in the compute SPF destination node is not in the PATH");
                }
            }
        }
        return allPath;
    }

    public List<Path> computeFullMeshSPF(Domain domain) throws RoutingException, NoRouteToHostException {
        return computeFullMeshSPF(domain, false);
    }

    public List<Path> computeFullMeshSPF(Domain domain, boolean ECMP) throws RoutingException, NoRouteToHostException {
        initComputation(domain);

        List<Path> pathList = new ArrayList<Path>();
        HashMap<String, CSPFElem> path = null;
        List<Path> allPath = null;
        List<Node> nodes = domain.getUpNodes();
        for (int i = 0; i < nodes.size(); i++) {
            Node node = nodes.get(i);
            if ((node.getNodeType() != Node.Type.VIRTUAL) && (node.getNodeType() != Node.Type.NEIGH)) {
                try {
                    path = computeCSPF(domain, domain.getMinPriority(), node, null, 0, false, true);
                    allPath = extractPath(domain, path, node, ECMP, true);
                } catch (NodeNotFoundException e) {
                    e.printStackTrace();
                }
                if (allPath != null) {
                    for (int j = 0; j < allPath.size(); j++) {
                        Path currentPath = (Path) allPath.get(j);
                        if (currentPath.getSourceNode() == null)
                            throw new RoutingException("Error in the compute SPF source node is not in the PATH");
                        pathList.add(currentPath);
                    }
                }
            }
        }
        return pathList;
    }

    protected float getMetric(Link link) {
        return link.getMetric();
    }

    /**
     * Computes the CSPF between a source node and a destination node with a bandwidth requirement
     *
     * @param srcNode    the source node
     * @param dstNode    the destination node
     * @param bw         the bandwidth demand
     * @return the hashmap of the path exploration
     * @throws be.ac.ulg.montefiore.run.totem.repository.model.exception.RoutingException
     *
     * @throws be.ac.ulg.montefiore.run.totem.repository.model.exception.NoRouteToHostException
     *
     */
    protected HashMap<String, CSPFElem> computeCSPF(Domain domain, int priority, Node srcNode, Node dstNode, float bw, boolean stopToSourceOrDestination, boolean computeFromSourceToDestination)
            throws RoutingException, NoRouteToHostException, NodeNotFoundException {
        if ((srcNode != null) && (dstNode != null)) {
            logger.info("CSPF: compute path from " + srcNode.getId() + " to " + dstNode.getId() + " for a bandwidth of " + bw);
            computeFromSourceToDestination = true; // force this value
        } else if ((srcNode != null) && computeFromSourceToDestination) {
            logger.info("CSPF: compute path from " + srcNode.getId() + " to all destinations for a bandwidth of " + bw);
        } else if ((dstNode != null) && !computeFromSourceToDestination) {
            logger.info("CSPF: compute path from all sources to " + dstNode.getId() + " for a bandwidth of " + bw);
        } else {
            logger.error("CSPF: invalid set of parameters!");
            throw new RoutingException("Invalid set of parameters!");
        }

        int nbNodes = domain.getNbNodes(); // number of nodes in the topology
        path = new HashMap<String, CSPFElem>(nbNodes); // current computed path
        tent = new CSPFPriorityQueue(nbNodes);
        presentInPath = new HashMap<Node, Boolean>(nbNodes);
        presentInTent = new HashMap<Node, Boolean>(nbNodes);
        distance = new HashMap<Node, Float>(nbNodes);

        CSPFElem pathNode;
        if (computeFromSourceToDestination) {
            pathNode = new CSPFElem(srcNode, 0, srcNode, -1, null);
            path.put(srcNode.getId(), pathNode);
            presentInPath.put(srcNode, new Boolean(PRESENT));
            distance.put(srcNode, new Float(0));
        } else {
            pathNode = new CSPFElem(dstNode, 0, dstNode, -1, null);
            path.put(dstNode.getId(), pathNode);
            presentInPath.put(dstNode, new Boolean(PRESENT));
            distance.put(dstNode, new Float(0));
        }
        logger.debug("Add node " + pathNode.getId() + " to PATH list (node: " + pathNode.getId() + ", dist: " + pathNode.getCost() + ", nh: " + pathNode.getNextHop().getId() + ", bw: " + pathNode.getBandwidth() + ")");

        if ((srcNode != null) && srcNode.equals(dstNode)) {
            return path;
        }

        List<Link> links;
        if (computeFromSourceToDestination) {
            links = srcNode.getOutLink();
        } else {
            links = dstNode.getInLink();
        }
        for (Link link : links) {
            if ((bw != 0) && currentBwManagement.getReservableBandwidth(priority, link, protectedLinks) < bw) {
                logger.info("Bandwidth available " + currentBwManagement.getReservableBandwidth(priority, link, protectedLinks) + " on the link " + link.getId() + " too small for routing " + bw + " from " + srcNode.getId() + " to " + dstNode.getId());
            } else if (avoidLinks.contains(link)) {
                logger.info("Avoid link " + link.getId());
            } else {
                relax(link, priority, computeFromSourceToDestination);
            }
        }

        while (tent.size() != 0) {
            logger.debug("*** NEXT ITERATION");
            pathNode = (CSPFElem) tent.removeNext();
            presentInTent.put(pathNode.getNode(), new Boolean(NOT_PRESENT));
            if (path.containsKey(pathNode.getId()))
                continue;
            path.put(pathNode.getId(), pathNode);
            logger.debug("Add node " + pathNode.getId() + " to PATH list (node: " + pathNode.getId() + ", dist: " + pathNode.getCost() + ", nh: " + pathNode.getNextHop().getId() + ", bw: " + pathNode.getBandwidth() + ")");
            presentInPath.put(pathNode.getNode(), new Boolean(PRESENT));
            
            // check if we reach the source or destination node
            if (stopToSourceOrDestination) {
                if (computeFromSourceToDestination && (pathNode.getId().equals(dstNode.getId()))) {
                    break;
                } else if (!computeFromSourceToDestination && (pathNode.getId().equals(srcNode.getId()))) {
                    break;
                }
            }

            if (computeFromSourceToDestination) {
                links = domain.getNode(pathNode.getId()).getOutLink();
            } else {
                links = domain.getNode(pathNode.getId()).getInLink();
            }

            if (logger.isDebugEnabled()) {
                StringBuffer sb = new StringBuffer("Explore node ");
                sb.append(pathNode.getId());
                if (computeFromSourceToDestination) {
                    sb.append(" - outlinks [");
                    for (Link link : links) {
                        sb.append(" " + link.getDstNode().getId());
                    }
                } else {
                    sb.append(" - inlinks [");
                    for (Link link : links) {
                        sb.append(" " + link.getSrcNode().getId());
                    }
                }
                sb.append("]");
                logger.debug(sb.toString());
            }

            for (Link link : links) {
                if ((bw != 0) && currentBwManagement.getReservableBandwidth(priority, link, protectedLinks) < bw) {
                    logger.info("Bandwidth available " + currentBwManagement.getReservableBandwidth(priority, link, protectedLinks) + " on the link " + link.getId() + " too small for routing " + bw + " from " + srcNode.getId() + " to " + dstNode.getId());
                } else if (avoidLinks.contains(link)) {
                    logger.debug("Avoid link " + link.getId());
                } else {
                    relax(link, priority, computeFromSourceToDestination);
                }
            }
        }

        if (stopToSourceOrDestination) {
            if (computeFromSourceToDestination && (!pathNode.getId().equals(dstNode.getId()))) {
                logger.warn("Exit without dstNode in the PATH (NoRouteToHostException)");
                if (logger.isDebugEnabled()) {
                    displayPath(path);
                }
                throw new NoRouteToHostException(srcNode, dstNode);
            } else if (!computeFromSourceToDestination && (!pathNode.getId().equals(srcNode.getId()))) {
                logger.warn("Exit without srcNode in the PATH (NoRouteToHostException)");
                if (logger.isDebugEnabled()) {
                    displayPath(path);
                }
                throw new NoRouteToHostException(srcNode, dstNode);
            }
        }

        return path;
    }

    protected void relax(Link link, int priority, boolean computeFromSourceToDestination) throws NodeNotFoundException {
        Node node, otherNode;
        if (computeFromSourceToDestination) {
            node = link.getDstNode();
            otherNode = link.getSrcNode();
        } else {
            node = link.getSrcNode();
            otherNode = link.getDstNode();
        }

        float linkBw = currentBwManagement.getReservableBandwidth(priority, link, protectedLinks);
        if ((presentInPath.get(node) == null) || (presentInPath.get(node)).booleanValue() != PRESENT) {
            float dist = this.getMetric(link);
            if (distance.get(otherNode) != null)
                dist += distance.get(otherNode).floatValue();
            if ((presentInTent.get(node) != null) && (((Boolean) presentInTent.get(node)).booleanValue() == PRESENT)) {
                logger.debug("Relax node " + node.getId() + " already in TENT list");
                // Update current node not in the PATH but already in the TENT list if needed
                if (dist < ((Float) distance.get(node)).floatValue()) {
                    distance.put(node, new Float(dist));
                    tent.update(new CSPFElem(node, dist, otherNode, linkBw, link));
                    logger.debug("Update node " + node.getId() + " to TENT list (node: " + node.getId() + ", dist: " + dist + ", nh: " + otherNode.getId() + ", bw: " + linkBw + ", link: " + link.getId() + " )");
                } else if (dist == (((Float) distance.get(node)).floatValue())) {
                    CSPFElem elem = (CSPFElem) tent.getElem(node.getId());
                    elem.addNextHop(otherNode);
                    elem.addLink(link);
                }
            } else {
                logger.debug("Relax node " + node.getId() + " not already in TENT list");
                // Add node w to the TENT list
                distance.put(node, new Float(dist));
                tent.add(new CSPFElem(node, dist, otherNode, linkBw, link));
                logger.debug("Add node " + node.getId() + " to TENT list (node: " + node.getId() + ", dist: " + dist + ", nh: " + otherNode.getId() + ", bw: " + linkBw + ", link: " + link.getId() + " )");
                presentInTent.put(node, new Boolean(PRESENT));
            }
        }
    }

    protected List<Path> extractPath(Domain domain, HashMap<String, CSPFElem> path, Node srcNode, Node dstNode, boolean ECMP, boolean computeFromSourceToDestination)
            throws RoutingException, NodeNotFoundException, NoRouteToHostException {
        if (path.size() == 0)
            return null;

        LinkedList<List<Node>> nodePathQueue = new LinkedList<List<Node>>();
        LinkedList<List<Link>> linkPathQueue = new LinkedList<List<Link>>();

        List<List<Link>> allReversePath = new ArrayList<List<Link>>();

        List<Node> currentNodePath = new ArrayList<Node>();
        currentNodePath.add(dstNode);
        nodePathQueue.add(currentNodePath);

        List<Link> currentLinkPath = new ArrayList<Link>();
        linkPathQueue.add(currentLinkPath);

        while (nodePathQueue.size() != 0) {
            currentNodePath = nodePathQueue.removeFirst();
            currentLinkPath = linkPathQueue.removeFirst();
            /*
            System.out.print("current path [ ");
            for (int j = 0; j < currentPath.size(); j++) {
            System.out.print(currentPath.get(j).getId() + " ");
            }
            System.out.println("]");
            */
            Node currentNode = currentNodePath.get(currentNodePath.size() - 1);
            innerLoop:
            while (true) {
                CSPFElem item = path.get(currentNode.getId());
                if (item == null)
                    throw new NoRouteToHostException("No route from " + srcNode.getId() + " to " + currentNode.getId(), srcNode, currentNode);
                List<Node> nextHopList = item.getNextHops();
                List<Link> links = item.getLinks();
                if (nextHopList.size() == 1) {
                    currentNode = nextHopList.get(0);
                    if (currentNode.equals(currentNodePath.get(currentNodePath.size() - 1))) {
                        //if (currentNode.equals(srcNode)) {
                        allReversePath.add(currentLinkPath);
                        /*
                        System.out.print("Add path to allReversePath [");
                        for (int k = 0; k < currentPath.size(); k++) {
                        System.out.print(currentPath.get(k).getId() + " ");
                        }
                        System.out.println("]");
                        */
                        break innerLoop;
                    } else {
                        currentNodePath.add(currentNode);
                        currentLinkPath.add(links.get(0));
                    }
                } else if (nextHopList.size() > 1) {
                    if (ECMP) {
                        for (int j = 1; j < nextHopList.size(); j++) {
                            @SuppressWarnings("unchecked")
                                    List<Node> newNodePath = (List<Node>) (((ArrayList<Node>) currentNodePath).clone());
                            newNodePath.add(nextHopList.get(j));
                            nodePathQueue.add(newNodePath);

                            @SuppressWarnings("unchecked")
                                    List<Link> newLinkPath = (List<Link>) (((ArrayList<Link>) currentLinkPath).clone());
                            newLinkPath.add(links.get(j));
                            linkPathQueue.add(newLinkPath);
                            /*
                            System.out.print("Add path to queue [ ");
                            for (int k = 0; k < newPath.size(); k++) {
                            System.out.print(newPath.get(k).getId() + " ");
                            }
                            System.out.println("]");
                            */
                        }
                    }
                    currentNode = nextHopList.get(0);
                    currentNodePath.add(currentNode);
                    currentLinkPath.add(links.get(0));
                } else {
                    System.out.println("CSPF ERROR : next hop list empty");
                }
            }
        }

        // let GC do his job
        nodePathQueue = null;
        linkPathQueue = null;
        currentNodePath = null;
        currentLinkPath = null;
        
        /*
        System.out.println("Display allReversePath");
        for (int i = 0; i < allReversePath.size(); i++) {
        List<Node> path1 = allReversePath.get(i);
        System.out.print("Path " + i + " : [ ");
        for (int j = 0; j < path1.size(); j++) {
        System.out.print(path1.get(j).getId() + " ");
        }
        System.out.println("]");

        }
        */
        
        List<Path> allPath = new ArrayList<Path>();
        for (List<Link> reversePath : allReversePath) {
            if (reversePath.size() != 0) {
                if (computeFromSourceToDestination) {
                    Collections.reverse(reversePath);
                }
                Path goodPath = new PathImpl(domain);
                try {
                    goodPath.createPathFromLink(reversePath);
                    allPath.add(goodPath);
                } catch (InvalidPathException e) {
                    //should never happen
                    logger.fatal("Invalid path.");
                }
            } else {
                // reversePath can only have a size of 0 if we compute a path
                // with same source and destination. (JLE)
                if (!srcNode.equals(dstNode)) {
                    throw new RoutingException("Path of size 0 and source different from destination!");
                }
                Path goodPath = new PathImpl(domain);
                List<Node> nodePath = new ArrayList<Node>(1);
                nodePath.add(srcNode);
                try {
                    goodPath.createPathFromNode(nodePath);
                    allPath.add(goodPath);
                } catch (InvalidPathException e) {
                    //should never happen
                    e.printStackTrace();
                }
            }
        }
        return allPath;
    }

    protected List<Path> extractPath(Domain domain, HashMap<String, CSPFElem> path, Node node, boolean ECMP, boolean computeFromSourceToDestination)
            throws RoutingException, NodeNotFoundException, NoRouteToHostException {
        if (path.size() == 0)
            return null;
        List<Node> nodeList = domain.getUpNodes();
        List<Path> pathList = new ArrayList<Path>(nodeList.size());
        for (Node currentNode : nodeList) {
            if (!currentNode.getId().equals(node.getId())) {
                List<Path> currentPaths = extractPath(domain, path, node, currentNode, ECMP, computeFromSourceToDestination);
                pathList.addAll(currentPaths);
            }
        }
        return pathList;
    }


    public void start() {
        start(null);
    }

    /**
     * Nothing to do
     */
    public void start(HashMap params) {
    }

    /**
     * Nothing to do
     */
    public void stop() {
    }

    // DEBUG
    /**
     * Debug method for displaying the TENT list
     *
     * @param tent
     */
    protected void displayTent(CSPFPriorityQueue tent) {
        tent.display();
    }

    /**
     * Debug method for displaying the Path
     *
     * @param path
     */
    protected void displayPath(HashMap<String, CSPFElem> path) {
        logger.debug("PATH list : ");
        for (Iterator<CSPFElem> iterator = path.values().iterator(); iterator.hasNext();) {
            CSPFElem tmpElem = iterator.next();
            StringBuffer sb = new StringBuffer("\t Node: ");
            sb.append(tmpElem.getId());
            sb.append(" : (cost: ");
            sb.append(tmpElem.getCost());
            sb.append(" next-hop: ");
            List<Node> nextHops = tmpElem.getNextHops();
            for (int i = 0; i < nextHops.size(); i++) {
                sb.append(nextHops.get(i).getId());
                sb.append(" ");
            }
            sb.append(")");
            logger.debug(sb.toString());
        }
    }

    public List<ParameterDescriptor> getStartAlgoParameters() {
        return (List<ParameterDescriptor>) emptyParamList.clone();
    }

    public HashMap getRunningParameters() {
        return null;
    }

    public List<ParameterDescriptor> getPrimaryRoutingParameters() {
        return (List<ParameterDescriptor>) emptyParamList.clone();
    }

    public List<ParameterDescriptor> getDetourRoutingParameters() {
        return (List<ParameterDescriptor>) detourParamList.clone();
    }

    public boolean equals(Object o) {
        if (!(o instanceof CSPF))
            return false;
        // Compare the class name since for example a CSPF-TE can't be equal to CSPF
        return getClass().getName().equals(o.getClass().getName());
    }

    public int hashCode() {
        return getClass().getName().hashCode();
    }

    /**
     * Computes a bypass based on the specified parameters.
     *
     * @param param specifies the parameters for the backup routing algorithm
     * @return the bypass computed
     * @throws RoutingException
     * @throws NoRouteToHostException
     */
    public TotemActionList routeBypass(Domain domain, LSPBypassRoutingParameter param) throws RoutingException, NoRouteToHostException {
        initComputation(domain);

        TotemActionList actionList = new TotemActionList();
        try {
            List<String> linksStr = null;
            try {
                linksStr = param.getProtectedLink();
                for (String s : linksStr) {
                    protectedLinks.add(domain.getLink(s));
                }
            } catch (LinkNotFoundException e) {
                throw new RoutingException("Unknown link to protect");
            }

            Link firstLink = protectedLinks.get(0);
            avoidLinks.add(firstLink);
            Link rLink = domain.getReverseLink(firstLink);
            if (rLink != null) avoidLinks.add(rLink);

            if (linksStr.size() > 1) {
                Link precLink = firstLink; //preceding link
                // avoid all links departing or arriving at intermediate nodes
                for (int i = 1; i < protectedLinks.size(); i++) {
                    Node intermediateNode = precLink.getDstNode();
                    Link nextLink = protectedLinks.get(i);
                    if (nextLink.getSrcNode() != intermediateNode) {
                        throw new RoutingException("Specified links are not contigous");
                    }
                    avoidLinks.addAll(intermediateNode.getAllInLink());
                    avoidLinks.addAll(intermediateNode.getAllOutLink());
                    precLink = nextLink;
                }
            }
            Node srcNode = firstLink.getSrcNode();
            Node dstNode;
            if (param.isSetDstNode()) {
                //if the bypass protects more than one link, the last link destination should be the destination node
                if (protectedLinks.size() > 1) {
                    if (domain.getNode(param.getDstNode()) != protectedLinks.get(protectedLinks.size()-1).getDstNode()) {
                        throw new RoutingException("The bypass LSP protects more than one link, so the destination should correspond to the last protected link destination");
                    }
                }
                // if the bypass also protects a node (destination node != destination of the last protected link)
                else if (domain.getNode(param.getDstNode()) != protectedLinks.get(protectedLinks.size()-1).getDstNode()) {
                    // we also need to avoid all links of the protected node.
                    Node protectedNode = protectedLinks.get(protectedLinks.size()-1).getDstNode();
                    avoidLinks.addAll(protectedNode.getAllInLink());
                    avoidLinks.addAll(protectedNode.getAllOutLink());
                }
                dstNode = domain.getNode(param.getDstNode());
            } else {
                dstNode = protectedLinks.get(protectedLinks.size()-1).getDstNode();
            }

            //need to compute a path between srcNode and dstNode

            String debugStr = "Avoid links: ";
            for (Link l : avoidLinks) {
                debugStr += l.getId() + " ";
            }
            logger.debug(debugStr);

            //use maximum priority when diffserv not specified
            int classType = param.isSetClassType() ? param.getClassType() : domain.getMinCTValue();
            if (param.isSetSetup() && !domain.getBandwidthManagement().usePreemption())
                logger.warn("The preemption level was specified but preemptions are not used on the domain. Ignoring.");
            int preemptionLevel = param.isSetSetup() ? param.getSetup() : domain.getMaxPreemptionLevel(classType);
            int holdingPreemptionLevel = param.isSetHolding() ? param.getHolding() : domain.getMaxPreemptionLevel(classType);
            if (!domain.isExistingPriority(preemptionLevel, classType)) {
                throw new RoutingException("Error with DiffServ configuration, non existing setup  priority level");
            }
            int priority = domain.getPriority(preemptionLevel, classType);
            if (!domain.isExistingPriority(holdingPreemptionLevel, classType)) {
                throw new RoutingException("Error with DiffServ configuration, non existing holding priority level");
            }

            float bw = param.getBandwidth();
            HashMap<String, CSPFElem> pathHM = computeCSPF(domain, priority, srcNode, dstNode, bw, true, true);
            List<Path> allPaths = extractPath(domain, pathHM, srcNode, dstNode, true, true);

            logger.debug("Found " + allPaths.size() + " shortest paths from " + srcNode.getId() + " to " + dstNode.getId());

            if (allPaths != null) {
                String lspId = param.getLspId();
                if (lspId == null) {
                    String protectedResource;
                    if (protectedLinks.size() == 1) {
                        if (protectedLinks.get(0).getDstNode() == dstNode)
                            protectedResource = protectedLinks.get(0).getId();
                        else protectedResource = protectedLinks.get(0).getDstNode().getId();
                    } else {
                        protectedResource = "";
                        for (Link l : protectedLinks) {
                            protectedResource += l.getId();
                        }
                    }
                    lspId = domain.generateBypassLspId(protectedResource);
                }

                LspImpl newLsp = new LspImpl(domain, lspId, param.getBandwidth(), allPaths.get(0), protectedLinks, classType, holdingPreemptionLevel, preemptionLevel);
                newLsp.setInitParameters(param);

                try {
                    List<Lsp> preemptList = currentBwManagement.getPreemptList(newLsp);
                    if (preemptList.size() > 0) {
                        List<String> lspIds = new ArrayList<String>(preemptList.size());
                        for (Lsp it : preemptList) {
                            lspIds.add(it.getId());
                        }
                        TotemAction preemptLsp = new PreemptLspsAction(domain, lspIds);
                        actionList.add(preemptLsp);

                        TotemAction addLsp = new AddLspAction(domain, newLsp);
                        actionList.add(addLsp);

                        actionList.add(new TriggerRerouteLspsAction(domain, preemptList));
                     } else {
                        TotemAction addLsp = new AddLspAction(domain, newLsp);
                        actionList.add(addLsp);
                     }
                } catch (LinkCapacityExceededException e) {
                    logger.fatal("Link Capacity Exceeded Exception: error in the path computation.");
                    throw new RoutingException("Error in the path computation.");
                }
            }
        } catch (NodeNotFoundException e) {
            e.printStackTrace();
            throw new RoutingException("Unexpected error: Node not found");
        } catch (DiffServConfigurationException e) {
            e.printStackTrace();
            throw new RoutingException("Error with DiffServ configuration, non existing priority level");
        }

        return actionList;
    }

    public List<ParameterDescriptor> getBypassRoutingParameters() {
        return (List<ParameterDescriptor>)emptyParamList.clone();
    }

    /**
     * Computes a detour backup for a LSP. The backups try to avoid the link to protect and also the reverse link (see
     * {@link Domain#getReverseLink(be.ac.ulg.montefiore.run.totem.domain.model.Link)} to see how the reverse link is
     * chosen).<br>
     *
     * Global backups are calculated as the shortest path that avoid all links of the primary and also the reverse links.<br>
     *
     * For local backups, see the options.
     *
     *
     * @param domain
     * @param param  specifies the parameters for the backup routing algorithm
     * @return the necessary list of action to add the detour to the network
     * @throws be.ac.ulg.montefiore.run.totem.repository.model.exception.RoutingException
     *
     * @throws be.ac.ulg.montefiore.run.totem.repository.model.exception.NoRouteToHostException
     *
     */
    public TotemActionList routeDetour(Domain domain, LSPDetourRoutingParameter param) throws RoutingException, NoRouteToHostException {
        initComputation(domain);

        TotemActionList actionList = new TotemActionList();

        Lsp primaryLsp = null;
        try {
            primaryLsp = domain.getLsp(param.getProtectedLSP());
        } catch (LspNotFoundException e) {
            //e.printStackTrace();
            throw new RoutingException("Primary lsp not found");
        }

        float bw;
        if (param.isSetBandwidth())
            bw = param.getBandwidth();
        else {
            bw = primaryLsp.getReservation();
            param.setBandwidth(bw);
        }

        int priority = domain.getPriority(primaryLsp.getSetupPreemption(), primaryLsp.getCT());
        List<Node> nodes = primaryLsp.getLspPath().getNodePath();

        try {
            if (param.getMethodType() == LSPDetourRoutingParameter.ALGORITHM_DEFAULT || param.getMethodType() == LSPDetourRoutingParameter.GLOBAL) {
                param.setMethodType(LSPDetourRoutingParameter.GLOBAL);
                int protectionType;
                if (param.getProtectionType() == LSPDetourRoutingParameter.LINK_DISJOINT) {
                    protectionType = LSPDetourRoutingParameter.LINK_DISJOINT;
                    protectedLinks =  new ArrayList<Link>(primaryLsp.getLspPath().getLinkPath().size());
                    avoidLinks = new HashSet<Link>(primaryLsp.getLspPath().getLinkPath().size()*2);
                    for (Link l : primaryLsp.getLspPath().getLinkPath()) {
                        protectedLinks.add(l);
                        avoidLinks.add(l);
                        Link rLink = domain.getReverseLink(l);
                        if (rLink != null) avoidLinks.add(l);
                    }
                } else { // node disjoint, global
                    protectionType = LSPDetourRoutingParameter.NODE_DISJOINT;
                    if (nodes.size() <= 2) {
                        throw new RoutingException("Impossible to protect nodes for LSP \"" + primaryLsp.getId() + "\": Path too small.");
                    }
                    protectedLinks = new ArrayList<Link>();
                    avoidLinks = new HashSet<Link>();
                    for (int i = 1; i < nodes.size() - 1; i++) {
                        Node n = nodes.get(i);
                        avoidLinks.addAll(n.getOutLink());
                        avoidLinks.addAll(n.getInLink());
                    }
                    protectedLinks.addAll(primaryLsp.getLspPath().getLinkPath());
                }

                HashMap<String, CSPFElem> pathHM = computeCSPF(domain, priority, nodes.get(0), nodes.get(nodes.size() - 1), bw, true, true);
                Path path = extractPath(domain, pathHM, nodes.get(0), nodes.get(nodes.size() - 1), false, true).get(0);
                if (path != null) {
                    StringBuffer sb = new StringBuffer("Path computed : [");
                    for (int i = 0; i < path.getNodePath().size(); i++) {
                        sb.append(" " + path.getNodePath().get(i).getId());
                    }
                    sb.append(" ]");
                    logger.debug(sb.toString());

                    String lspId = param.getLspId() == null ? domain.generateDetourLspId(primaryLsp.getId(), LSPDetourRoutingParameter.GLOBAL, protectionType) : param.getLspId();
                    LspImpl newLsp = new LspImpl(domain, primaryLsp.getId(), lspId, path, LspBackupType.DETOUR_E_2_E, protectedLinks);
                    newLsp.setInitParameters(param);
                    try {
                        List<Lsp> preemptList = currentBwManagement.getPreemptList(newLsp);
                        if (preemptList.size() > 0) {
                            List<String> lspIds = new ArrayList<String>(preemptList.size());
                            for (Lsp it : preemptList) {
                                lspIds.add(it.getId());
                            }
                            TotemAction preemptLsp = new PreemptLspsAction(domain, lspIds);
                            actionList.add(preemptLsp);

                            TotemAction addLsp = new AddLspAction(domain, newLsp);
                            actionList.add(addLsp);

                            actionList.add(new TriggerRerouteLspsAction(domain, preemptList));
                         } else {
                            TotemAction addLsp = new AddLspAction(domain, newLsp);
                            actionList.add(addLsp);
                         }
                    } catch (LinkCapacityExceededException e) {
                        logger.fatal("Link Capacity Exceeded Exception: error in the path computation.");
                        throw new RoutingException("Error in the path computation.");
                    }
                }
            } else { //local protection
                // use a snapshot
                currentBwManagement = currentBwManagement.getSnapshot();

                MergingPointLocation mpLocation;
                if (param != null && param.getRoutingAlgorithmParameter("mergePointLocation") != null && param.getRoutingAlgorithmParameter("mergePointLocation").equalsIgnoreCase("nearest")) {
                    mpLocation = MergingPointLocation.NEAREST_MERGING_POINT;
                } else {
                    //default
                    mpLocation = MergingPointLocation.FARTHEST_MERGING_POINT;
                }

                MergingPointPriority mpPriority;
                if (param != null && param.getRoutingAlgorithmParameter("mergePointPriority") != null && param.getRoutingAlgorithmParameter("mergePointPriority").equalsIgnoreCase("location")) {
                    mpPriority = MergingPointPriority.LOCATION_PRIORITY;
                } else {
                    //default
                    mpPriority = MergingPointPriority.END_TO_END_COST_PRIORITY;
                }

                boolean stopOnError;
                if (param != null && param.getRoutingAlgorithmParameter("stopOnError") != null && param.getRoutingAlgorithmParameter("stopOnError").equalsIgnoreCase("true")) {
                    stopOnError = true;
                } else {
                    stopOnError = false;
                }


                //local, link disjoint
                if (param.getProtectionType() == LSPDetourRoutingParameter.LINK_DISJOINT) {
                    nbBackups = 0;
                    int nbFoundBackups = 0;
                    HashSet<Link> baseAvoidLinks = new HashSet<Link>(2);
                    for (Link l : primaryLsp.getLspPath().getLinkPath()) {
                        baseAvoidLinks.add(l);
                        Link rLink = domain.getReverseLink(l);
                        if (rLink != null) baseAvoidLinks.add(rLink);
                    }

                    for (Link l : primaryLsp.getLspPath().getLinkPath()) {

                        protectedLinks = new ArrayList<Link>(1);
                        protectedLinks.add(l);

                        Node pointOfFailure = l.getSrcNode();

                        Path path = null;

                        MergingPointIterator mpi;
                        if (mpLocation == MergingPointLocation.NEAREST_MERGING_POINT)
                            mpi = new NearestMergingPointIterator(nodes, l);
                        else mpi = new FarthestMergingPointIterator(nodes, l);
                        Node mergingPoint = mpi.getFirstMergingPoint();

                        // links to avoid during computation of the path
                        avoidLinks = new HashSet<Link>();
                        if (mpPriority == MergingPointPriority.LOCATION_PRIORITY) {
                            List<Path> paths = null;
                            boolean foundPath = false;
                            /* cycle till we found a found a path or we try all merging points */
                            while (!foundPath && mpi.isMergingPoint()) {
                                /* add the links of the primary */
                                avoidLinks.addAll(baseAvoidLinks);
                                /* also add the nodes between the point of failure and the merging point (all incoming and outgoing links) */
                                int i = nodes.indexOf(pointOfFailure);
                                int j = nodes.indexOf(mergingPoint);
                                for (int k=i+1; k < j; k++) {
                                    avoidLinks.addAll(nodes.get(k).getAllInLink());
                                    avoidLinks.addAll(nodes.get(k).getAllOutLink());
                                }

                                try {
                                    paths = findLocalBackupPath(domain, priority, pointOfFailure, mergingPoint, bw);
                                    foundPath = true;
                                } catch (Exception e) {
                                    logger.debug("No path found from node " + pointOfFailure.getId() + " to " + mergingPoint.getId());
                                    mergingPoint = mpi.getNextMergingPoint();
                                    avoidLinks.clear();
                                }
                            }
                            if (foundPath) {
                                path = paths.get(0);
                            }
                        } else { //cost priority
                            float minCost = Float.MAX_VALUE;
                            /* cycle through all possible merging points */
                            while (mpi.isMergingPoint()) {
                                /* add the links of the primary */
                                avoidLinks.addAll(baseAvoidLinks);
                                /* also add the nodes between the point of failure and the merging point (all incoming and outgoing links) */
                                int i = nodes.indexOf(pointOfFailure);
                                int j = nodes.indexOf(mergingPoint);
                                for (int k=i+1; k < j; k++) {
                                    avoidLinks.addAll(nodes.get(k).getAllInLink());
                                    avoidLinks.addAll(nodes.get(k).getAllOutLink());
                                }

                                try {
                                    List<Path> paths = findLocalBackupPath(domain, priority, pointOfFailure, mergingPoint, bw);
                                    /* compute the cost of the path from the point of failure to the egress of the primary */
                                    /* as we use the iterator in the location order, so paths with equal cost can be dropped.*/
                                    float cost = getLocalLSPCostToEnd(paths.get(0), primaryLsp.getLspPath());
                                    if (cost < minCost) {
                                        minCost = cost;
                                        path = paths.get(0);
                                    }
                                } catch (Exception e) {
                                    logger.debug("No path found from node " + pointOfFailure.getId() + " to " + mergingPoint.getId());
                                }
                                mergingPoint = mpi.getNextMergingPoint();
                                avoidLinks.clear();
                            }
                        }

                        if (path != null) {
                            createActionList(domain, param, primaryLsp, path, actionList, LSPDetourRoutingParameter.LINK_DISJOINT);
                            nbFoundBackups++;
                        } else if (stopOnError) {
                            throw new NoRouteToHostException("Couldn't find a path satisfying the requirements.");
                        } else {
                            logger.warn("No path found protecting link " + l.getId());
                        }
                    }
                    if (nbFoundBackups == 0) {
                        throw new NoRouteToHostException("Couldn't find a path satisfying the requirements.");
                    } else if (nbFoundBackups != primaryLsp.getLspPath().getLinkPath().size()) {
                        logger.warn("Not all links could be protected.");
                    }
                } else { // node disjoint, local backups
                    if (nodes.size() <= 2) {
                        throw new RoutingException("Impossible to protect nodes for LSP \"" + primaryLsp.getId() + "\": Path too small.");
                    }
                    nbBackups = 0;
                    int nbFoundBackups = 0;
                    for (int n = 1; n < nodes.size() - 1; n++) {
                        Node protectedNode = nodes.get(n);
                        Node pointOfFailure = nodes.get(n-1);
                        HashSet<Link> baseAvoidLinks = new HashSet<Link>();
                        protectedLinks = new ArrayList<Link>(1);
                        baseAvoidLinks.addAll(protectedNode.getInLink());
                        baseAvoidLinks.addAll(protectedNode.getOutLink());
                        protectedLinks.add(primaryLsp.getLspPath().getLinkPath().get(n-1));
                        for (Link l : primaryLsp.getLspPath().getLinkPath()) {
                            baseAvoidLinks.add(l);
                            Link rLink = domain.getReverseLink(l);
                            if (rLink != null) baseAvoidLinks.add(rLink);
                        }

                        MergingPointIterator mpi;
                        if (mpLocation == MergingPointLocation.NEAREST_MERGING_POINT)
                            mpi = new NearestMergingPointIterator(nodes, protectedNode);
                        else mpi = new FarthestMergingPointIterator(nodes, protectedNode);
                        Node mergingPoint = mpi.getFirstMergingPoint();

                        Path path = null;

                        // links to avoid during computation of the path
                        avoidLinks = new HashSet<Link>();
                        if (mpPriority == MergingPointPriority.LOCATION_PRIORITY) {
                            List<Path> paths = null;
                            boolean foundPath = false;
                            /* cycle till we found a found a path or we try all merging points */
                            while (!foundPath && mpi.isMergingPoint()) {
                                /* add the links of the primary */
                                avoidLinks.addAll(baseAvoidLinks);
                                /* also add the nodes between the point of failure and the merging point (all incoming and outgoing links) */
                                int i = nodes.indexOf(protectedNode);
                                int j = nodes.indexOf(mergingPoint);
                                for (int k=i+1; k < j; k++) {
                                    avoidLinks.addAll(nodes.get(k).getAllInLink());
                                    avoidLinks.addAll(nodes.get(k).getAllOutLink());
                                }

                                try {
                                    paths = findLocalBackupPath(domain, priority, pointOfFailure, mergingPoint, bw);
                                    foundPath = true;
                                } catch (Exception e) {
                                    logger.debug("No path found from node " + pointOfFailure.getId() + " to " + mergingPoint.getId());
                                    mergingPoint = mpi.getNextMergingPoint();
                                    avoidLinks.clear();
                                }
                            }
                            if (foundPath) {
                                path = paths.get(0);
                            }
                        } else { //cost priority
                            float minCost = Float.MAX_VALUE;
                            /* cycle through all possible merging points */
                            while (mpi.isMergingPoint()) {
                                /* add the links of the primary */
                                avoidLinks.addAll(baseAvoidLinks);
                                /* also add the nodes between the protected node and the merging point (all incoming and outgoing links) */
                                int i = nodes.indexOf(protectedNode);
                                int j = nodes.indexOf(mergingPoint);
                                for (int k=i+1; k < j; k++) {
                                    avoidLinks.addAll(nodes.get(k).getAllInLink());
                                    avoidLinks.addAll(nodes.get(k).getAllOutLink());
                                }

                                try {
                                    List<Path> paths = findLocalBackupPath(domain, priority, pointOfFailure, mergingPoint, bw);
                                    /* compute the cost of the path from the point of failure to the egress of the primary */
                                    /* as we use the iterator in the location order, so paths with equal cost can be dropped.*/
                                    float cost = getLocalLSPCostToEnd(paths.get(0), primaryLsp.getLspPath());
                                    if (cost < minCost) {
                                        minCost = cost;
                                        path = paths.get(0);
                                    }
                                } catch (Exception e) {
                                    logger.debug("No path found from node " + pointOfFailure.getId() + " to " + mergingPoint.getId());
                                }
                                mergingPoint = mpi.getNextMergingPoint();
                                avoidLinks.clear();
                            }
                        }
                        if (path != null) {
                            createActionList(domain, param, primaryLsp, path, actionList, LSPDetourRoutingParameter.NODE_DISJOINT);
                            nbFoundBackups++;
                        } else if (stopOnError) {
                            throw new NoRouteToHostException("Couldn't find a path satisfying the requirements.");
                        } else {
                            logger.warn("Could not find a path protecting node " + protectedNode.getId());
                        }
                    }
                    if (nbFoundBackups == 0) {
                        throw new NoRouteToHostException("Couldn't find a path satisfying the requirements.");
                    } else if (nbFoundBackups < nodes.size()-2) {
                        logger.warn("Not all nodes could be protected.");
                    }
                }
                if (param.getProtectionType() == LSPDetourRoutingParameter.ALGORITHM_DEFAULT) {
                    // also protect last link

                    List<Link> linkPath = primaryLsp.getLspPath().getLinkPath();

                    avoidLinks = new HashSet<Link>(2);
                    for (Link l : linkPath) {
                        avoidLinks.add(l);
                        Link rLink = domain.getReverseLink(l);
                        if (rLink != null) avoidLinks.add(rLink);
                    }

                    Link l = linkPath.get(linkPath.size()-1);

                    protectedLinks = new ArrayList<Link>(1);
                    protectedLinks.add(l);

                    Node pointOfFailure = l.getSrcNode();
                    Node mergingPoint = l.getDstNode();

                    List<Path> paths = null;
                    try {
                        paths = findLocalBackupPath(domain, priority, pointOfFailure, mergingPoint, bw);
                    } catch (Exception e) {
                        logger.debug("No path found from node " + pointOfFailure.getId() + " to " + mergingPoint.getId());
                    }

                    if (paths != null && paths.size() > 0) {
                        createActionList(domain, param, primaryLsp, paths.get(0), actionList, LSPDetourRoutingParameter.LINK_DISJOINT);
                    } else if (stopOnError) {
                         throw new NoRouteToHostException("Couldn't find a path satisfying the requirements while protecting last link.");
                    } else {
                        logger.warn("Could not protect last link in path.");
                    }
                }
            }
        } catch (NodeNotFoundException e) {
            logger.error("Node not found");
            throw new RoutingException("Node not found");
        } catch (LspAlreadyExistException e) {
            logger.error("Lsp already exists");
            throw new RoutingException("Lsp id already exists in the domain");
        }
        return actionList;
    }

    //TODO: Test this.
    private float getLocalLSPCostToEnd(Path localPath, Path primaryPath) {
        float cost = 0;
        for (Link l : localPath.getLinkPath()) {
            cost += getMetric(l);
        }
        Node mergingPoint = localPath.getDestinationNode();
        int index = primaryPath.getNodePath().indexOf(mergingPoint);
        for (int i = index; i < primaryPath.getLinkPath().size(); i++) {
            cost+=getMetric(primaryPath.getLinkPath().get(index));
        }
        return cost;
    }

    private List<Path> findLocalBackupPath(Domain domain, int priority, Node src, Node dst, float bw) throws NoRouteToHostException, NodeNotFoundException, RoutingException {
        String debugStr = "Avoid links: ";
        for (Link l : avoidLinks) {
            debugStr += l.getId() + " ";
        }
        logger.debug(debugStr);

        HashMap<String, CSPFElem> pathHM = computeCSPF(domain, priority, src, dst, bw, true, true);
        List<Path> allPaths = extractPath(domain, pathHM, src, dst, true, true);

        logger.debug("Found " + allPaths.size() + " shortest paths from " + src.getId() + " to " + dst.getId());

        return allPaths;
    }

    //TODO: Reroute LSPs should occur only after all LSPs are preempted and new lsps are established (end of action list)
    /**
     *
     * @param domain
     * @param param
     * @param primaryLsp
     * @param path
     * @param actionList
     * @param protectionType Only used to generate the lsp id.
     * @return
     * @throws RoutingException
     * @throws LspAlreadyExistException
     */
    private TotemActionList createActionList(Domain domain, LSPDetourRoutingParameter param, Lsp primaryLsp, Path path, TotemActionList actionList, int protectionType) throws RoutingException, LspAlreadyExistException {
        StringBuffer sb = new StringBuffer("Path computed : [");
        for (int i = 0; i < path.getNodePath().size(); i++) {
            sb.append(" " + path.getNodePath().get(i).getId());
        }
        sb.append(" ]");
        logger.debug(sb.toString());

        String lspId;
        if (param.getLspId() == null)
            lspId = domain.generateDetourLspId(primaryLsp.getId(), LSPDetourRoutingParameter.LOCAL, protectionType);
        else {
            lspId = param.getLspId() + "-" + nbBackups++;
            logger.debug("Lsp id: " + lspId);
            domain.getConvertor().addLspId(lspId);
        }

        LspImpl newLsp = new LspImpl(domain, primaryLsp.getId(), lspId, path, LspBackupType.DETOUR_LOCAL, protectedLinks);
        param.setMethodType(LSPDetourRoutingParameter.LOCAL);
        newLsp.setInitParameters(param);

        try {
            List<Lsp> preemptList = currentBwManagement.getPreemptList(newLsp);
            if (preemptList.size() > 0) {
                List<String> lspIds = new ArrayList<String>(preemptList.size());
                for (Lsp it : preemptList) {
                    try {
                        currentBwManagement.removeLsp(it);
                    } catch (DiffServConfigurationException e) {
                        e.printStackTrace();
                    } catch (LspNotFoundException e) {
                        e.printStackTrace();
                    }
                    lspIds.add(it.getId());
                }
                TotemAction preemptLsp = new PreemptLspsAction(domain, lspIds);
                actionList.add(preemptLsp);

                TotemAction addLsp = new AddLspAction(domain, newLsp);
                actionList.add(addLsp);
                currentBwManagement.addLsp(newLsp);

                actionList.add(new TriggerRerouteLspsAction(domain, preemptList));
            } else {
                TotemAction addLsp = new AddLspAction(domain, newLsp);
                actionList.add(addLsp);
                currentBwManagement.addLsp(newLsp);
            }
        } catch (LinkCapacityExceededException e) {
            logger.fatal("Link Capacity Exceeded Exception: error in the path computation.");
            throw new RoutingException("Error in the path computation.");
        } catch (DiffServConfigurationException e) {
            e.printStackTrace();
        } catch (LspNotFoundException e) {
            e.printStackTrace();
        }
        return actionList;
    }

    private interface MergingPointIterator {
        Node getFirstMergingPoint();
        boolean isMergingPoint();
        Node getNextMergingPoint();
    }

    private class NearestMergingPointIterator implements MergingPointIterator {
        private List<Node> primaryNodePath;
        private int mergingNodeIndex;
        private int firstMergingNodeIndex;

        public NearestMergingPointIterator(List<Node> primaryNodePath, Node protectedNode) {
            this.primaryNodePath = primaryNodePath;
            this.mergingNodeIndex = primaryNodePath.indexOf(protectedNode)+1;
            this.firstMergingNodeIndex = mergingNodeIndex;
        }

        public NearestMergingPointIterator(List<Node> primaryNodePath, Link protectedLink) {
            this.primaryNodePath = primaryNodePath;
            try {
                this.mergingNodeIndex = primaryNodePath.indexOf(protectedLink.getDstNode());
                this.firstMergingNodeIndex = mergingNodeIndex;
            } catch (NodeNotFoundException e) {
                e.printStackTrace();
                logger.fatal(e);
            }
        }

        public Node getFirstMergingPoint() {
            mergingNodeIndex = firstMergingNodeIndex;
            return primaryNodePath.get(mergingNodeIndex);
        }

        public boolean isMergingPoint() {
            return mergingNodeIndex < primaryNodePath.size();
        }

        public Node getNextMergingPoint() {
            mergingNodeIndex++;
            if (isMergingPoint()) return primaryNodePath.get(mergingNodeIndex);
            return null;
        }
    }

    private class FarthestMergingPointIterator implements MergingPointIterator {
        private List<Node> primaryNodePath;
        private int mergingNodeIndex;
        private int lastMergingNodeIndex;

        public FarthestMergingPointIterator(List<Node> primaryNodePath, Node protectedNode) {
            this.primaryNodePath = primaryNodePath;
            this.mergingNodeIndex = primaryNodePath.size()-1;
            this.lastMergingNodeIndex = primaryNodePath.indexOf(protectedNode)+1;
        }

        public FarthestMergingPointIterator(List<Node> primaryNodePath, Link protectedLink) {
            this.primaryNodePath = primaryNodePath;
            this.mergingNodeIndex = primaryNodePath.size()-1;
            try {
                this.lastMergingNodeIndex = primaryNodePath.indexOf(protectedLink.getDstNode());
            } catch (NodeNotFoundException e) {
                e.printStackTrace();
                logger.fatal(e);
            }
        }

        public Node getFirstMergingPoint() {
            this.mergingNodeIndex = primaryNodePath.size()-1;
            return primaryNodePath.get(mergingNodeIndex);
        }

        public boolean isMergingPoint() {
            return mergingNodeIndex >= lastMergingNodeIndex;
        }

        public Node getNextMergingPoint() {
            mergingNodeIndex--;
            if (isMergingPoint())
                return primaryNodePath.get(mergingNodeIndex);
            else return null;
        }
    }
}
